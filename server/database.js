//Import dotenv for database connections
import 'dotenv/config';
import pg from 'pg';

// Get the Pool class from the pg module.
const { Pool } = pg;

export class Database {
  constructor(dburl) {
    this.dburl = dburl;
  }

  async connect() {
    this.pool = new Pool({
      connectionString: this.dburl,
      ssl: { rejectUnauthorized: false }, // Required for Heroku connections
    });

    // Create the pool.
    this.client = await this.pool.connect();

    // Init the database.
    await this.init();
  }

  async init() {
    //This array allows querys to be autogenerated based on argument inputs
    this.cols = [
      { id: 'id', type: 'string' },
      { id: 'img', type: 'string' },
      { id: 'name', type: 'string' },
      { id: 'description', type: 'string' },
      { id: 'location', type: 'string' },
      { id: 'room', type: 'number' },
      { id: 'floor', type: 'number' },
      { id: 'sun', type: 'boolean' },
      { id: 'mon', type: 'boolean' },
      { id: 'tue', type: 'boolean' },
      { id: 'wed', type: 'boolean' },
      { id: 'thu', type: 'boolean' },
      { id: 'fri', type: 'boolean' },
      { id: 'sat', type: 'boolean' },
      { id: 'seats', type: 'number' },
      { id: 'tables', type: 'number' },
      { id: 'ports', type: 'number' },
      { id: 'whiteboard', type: 'boolean' },
      { id: 'outside', type: 'boolean' }
    ];

    const queryText = `
      CREATE TABLE IF NOT EXISTS places (
        id varchar(30) PRIMARY KEY,
        img text,
        name varchar(30),
        description varchar(250),
        location text,
        room int,
        floor int,
        sun bool,
        mon bool,
        tue bool,
        wed bool,
        thu bool,
        fri bool,
        sat bool,
        seats int,
        tables int,
        ports int,
        whiteboard bool,
        outside bool
        );
        `;
    const res = await this.client.query(queryText);
    // console.log(queryText);
  }

  // Close the pool.
  async close() {
    this.client.release();
    await this.pool.end();
  }


  /**
   * Adds a new location to the database. Will throw an error if the information is invalid
   */
  async createArea(id, img, name, description, location, room, floor, sun, mon, tue, wed, thu, fri, sat, seats, tables, ports, whiteboard, outside) {
    //Insert all data values
    let query = 'INSERT INTO places(id, img, name, description, location, room, floor, sun, mon, tue, wed, thu, fri, sat, seats, tables, ports, whiteboard, outside) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19) RETURNING *';
    //Check that all values are valid
    for (let i = 0; i < arguments.length; ++i) {
      if (typeof arguments[i] !== this.cols[i].type) {
        return { ok: false, error: `${this.cols[i].id} must be of type ${this.cols[i].type}` };
      }
    }
    const res = await this.client.query(query, [id, img, name, description, location, room, floor, sun, mon, tue, wed, thu, fri, sat, seats, tables, ports, whiteboard, outside]);
    return { ok: true, rows: res.rows };
    // return { ok: true, rows: query.length };
  }

  /**
   * Returns a room with the specified ID
   * 
   * @param {String} id 
   */
  async readArea(id) {
    let query = 'SELECT * FROM places WHERE id="$1"';
    const res = await this.client.query(query, [id]);
    return { ok: true, rows: res.rows };
    // return { ok: true, rows: query }
  }

  /**
   * Querys the database based on the valid parameters
   */
  async searchAreas(id, img, name, description, location, room, floor, sun, mon, tue, wed, thu, fri, sat, seats, tables, ports, whiteboard, outside) {
    //The query should only search the inputs that are selected
    let query = 'SELECT * FROM places WHERE';

    //Build the query by taking arguments that have truthy values, as empty strings and false are not to be searched
    let ins = 1;
    let values = [];
    for (let i = 0; i < arguments.length; ++i) {
      if (arguments[i]) {
        if (typeof arguments[i] === this.cols[i].type) {
          //Add to the query with the safe postgresql information
          query += (ins > 1 ? ' AND ' : ' ') + this.cols[i].id + '=$' + ins++;

          //Push the needed value to the values array
          values.push(arguments[i]);
        } else {
          return { ok: false, error: `${this.cols[i].id} must be of type ${this.cols[i].type}: ${arguments[i]}, ${typeof arguments[i]}` };
        }
      }
    }

    if (values.length < 2) {
      return { ok: false, error: `Not enough parameters: ${values.length}` };
    }

    query += ' ORDER BY location DESC';

    //Query on the values that were requested
    const res = await this.client.query(query, values);
    return { ok: true, rows: res.rows };
    // return { ok: true, rows: { query: query, values: values } }
  }

  async updateArea(id, img, name, description, location, room, floor, sun, mon, tue, wed, thu, fri, sat, seats, tables, ports, whiteboard, outside) {
    //The query should only search the inputs that are selected
    let query = 'UPDATE places SET ';

    //Build the query by taking arguments that have truthy values, as empty strings, undefined and false are not to be searched
    //Skip the id arg. ID will never be updated
    let ins = 2;
    let values = [];
    for (let i = 1; i < arguments.length; ++i) {
      if (arguments[i]) {
        //Check that all values are valid
        if (typeof arguments[i] !== this.cols[i].type) {
          //Add to the query with the safe postgresql information
          query += (ins > 2 ? '' : ', ') + this.cols[i].id + '=$' + ins++;

          //Push the needed value to the values array
          values.push(arguments[i]);
        } else {
          throw `${this.cols[i].id} must be of type ${this.cols[i].type}`;
        }
      }
    }

    //Remove extra comma
    query = query.split('').splice(query.length - 2, 1).join('');

    //Return updated row where ids match
    query += ' WHERE id=$1 RETURNING *';

    //Query on the values that were requested as well as the id
    const res = await this.client.query(query, [id, ...values]);
    return { ok: true, rows: res.rows };
    // return { ok: true, rows: { query: query, values: values } }
  }

  async deleteArea(id) {
    let query = 'DELETE FROM places WHERE id=$1 RETURNING *';
    const res = await this.client.query(query, [id]);
    return { ok: true, rows: res.rows };
    // return { ok: true, rows: query }
  }
}

const database = new Database(process.env.DATABASE_URL);

export { database };