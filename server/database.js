//Import dotenv for database connections
import 'dotenv/config';
import pg from 'pg';

// Get the Pool class from the pg module.
const { Pool } = pg;

export class Database {
  constructor(dburl) {
    this.dburl = dburl;
  }

  async connect() {
    this.pool = new Pool({
      connectionString: this.dburl,
      ssl: { rejectUnauthorized: false }, // Required for Heroku connections
    });

    // Create the pool.
    this.client = await this.pool.connect();

    // Init the database.
    await this.init();
  }

  async init() {
    //This array allows querys to be autogenerated based on argument inputs
    this.cols = [
      { id: 'id', type: 'string', match: '=' },
      { id: 'img', type: 'string', match: '=' },
      { id: 'name', type: 'string', match: '=' },
      { id: 'description', type: 'string', match: '=' },
      { id: 'location', type: 'string', match: '=' },
      { id: 'room', type: 'number', match: '=' },
      { id: 'floor', type: 'number', match: '=' },
      { id: 'sun', type: 'boolean', match: '=' },
      { id: 'mon', type: 'boolean', match: '=' },
      { id: 'tue', type: 'boolean', match: '=' },
      { id: 'wed', type: 'boolean', match: '=' },
      { id: 'thu', type: 'boolean', match: '=' },
      { id: 'fri', type: 'boolean', match: '=' },
      { id: 'sat', type: 'boolean', match: '=' },
      { id: 'seats', type: 'number', match: '>=' },
      { id: 'tables', type: 'number', match: '>=' },
      { id: 'ports', type: 'number', match: '>=' },
      { id: 'whiteboard', type: 'boolean', match: '=' },
      { id: 'outside', type: 'boolean', match: '=' }
    ];

    const queryText = `
      CREATE TABLE IF NOT EXISTS places (
        id varchar(30) PRIMARY KEY,
        img text,
        name varchar(30),
        description varchar(250),
        location text,
        room int,
        floor int,
        sun bool,
        mon bool,
        tue bool,
        wed bool,
        thu bool,
        fri bool,
        sat bool,
        seats int,
        tables int,
        ports int,
        whiteboard bool,
        outside bool
        );

        CREATE TABLE IF NOT EXISTS users (
          name varchar(30),
          password varchar(100)
        );
        `;
    const res = await this.client.query(queryText);
  }

  // Close the pool.
  async close() {
    this.client.release();
    await this.pool.end();
  }

  // Area table


  /**
   * Adds a new location to the database. Will throw an error if the information is invalid
   */
  async createArea(id, img, name, description, location, room, floor, sun, mon, tue, wed, thu, fri, sat, seats, tables, ports, whiteboard, outside) {
    //Insert all data values
    let query = 'INSERT INTO places(id, img, name, description, location, room, floor, sun, mon, tue, wed, thu, fri, sat, seats, tables, ports, whiteboard, outside) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19) RETURNING *';
    //Check that all values are valid
    for (let i = 0; i < arguments.length; ++i) {
      if (typeof arguments[i] !== this.cols[i].type) {
        return { ok: false, error: `${this.cols[i].id} must be of type ${this.cols[i].type}` };
      }
    }
    const res = await this.client.query(query, [id, img, name, description, location, room, floor, sun, mon, tue, wed, thu, fri, sat, seats, tables, ports, whiteboard, outside]);
    return { ok: true, rows: res.rows };
  }

  /**
   * Returns a room with the specified ID
   * 
   * @param {String} id 
   */
  async readArea(id) {
    let query = 'SELECT * FROM places WHERE id="$1"';
    const res = await this.client.query(query, [id]);
    return { ok: true, rows: res.rows };
  }

  /**
   * Querys the database based on the valid parameters
   */
  async searchAreas(id, img, name, description, location, room, floor, sun, mon, tue, wed, thu, fri, sat, seats, tables, ports, whiteboard, outside) {
    //The query should only search the inputs that are selected
    let query = 'SELECT * FROM places WHERE';

    //Build the query by taking arguments that have truthy values, as empty strings and false are not to be searched
    let ins = 1;
    let values = [];
    for (let i = 0; i < arguments.length; ++i) {
      if (arguments[i] || arguments[i] === 0) {
        if (typeof arguments[i] === this.cols[i].type) {
          //Add to the query with the safe postgresql information
          query += (ins > 1 ? ' AND ' : ' ') + this.cols[i].id + this.cols[i].match + '$' + ins++;

          //Push the needed value to the values array
          values.push(arguments[i]);
        } else {
          return { ok: false, error: `${this.cols[i].id} must be of type ${this.cols[i].type}: ${arguments[i]}, ${typeof arguments[i]}` };
        }
      }
    }

    if (values.length < 2) {
      return { ok: false, error: `Not enough parameters: ${values.length}` };
    }

    query += ' ORDER BY location DESC';

    //Query on the values that were requested
    const res = await this.client.query(query, values);
    return { ok: true, rows: res.rows };
  }

  async updateArea(id, img, name, description, location, room, floor, sun, mon, tue, wed, thu, fri, sat, seats, tables, ports, whiteboard, outside) {
    //The query should only search the inputs that are selected
    let query = 'UPDATE places SET ';

    //Build the query by taking arguments that have truthy values, as empty strings, undefined and false are not to be searched
    //Skip the id arg. ID will never be updated
    let ins = 2;
    let values = [];
    for (let i = 1; i < arguments.length; ++i) {
      if (arguments[i] || arguments[i] === 0) {
        //Check that all values are valid
        if (typeof arguments[i] !== this.cols[i].type) {
          //Add to the query with the safe postgresql information
          query += (ins > 2 ? '' : ', ') + this.cols[i].id + '=$' + ins++;

          //Push the needed value to the values array
          values.push(arguments[i]);
        } else {
          return { ok: false, error: `${this.cols[i].id} must be of type ${this.cols[i].type}` };
        }
      }
    }

    //Remove extra comma
    query = query.split('').splice(query.length - 2, 1).join('');

    //Return updated row where ids match
    query += ' WHERE id=$1 RETURNING *';

    //Query on the values that were requested as well as the id
    const res = await this.client.query(query, [id, ...values]);
    return { ok: true, rows: res.rows };
  }

  async deleteArea(id) {
    let query = 'DELETE FROM places WHERE id=$1 RETURNING *';
    const res = await this.client.query(query, [id]);
    return { ok: true, rows: res.rows };
  }

  // User table

  async addUser(name, pass) {
    let query = 'INSERT INTO users(name, password) values ($1, $2) RETURNING *';
    const res = await this.client.query(query, [name, pass]);
    return { ok: true, rows: res.rows };
  }
  
  async validateUser(name, pass) {
    let query = 'SELECT * FROM users WHERE name=$1 AND password=$2';
    const res = await this.client.query(query, [name, pass]);
    console.log('valid', res.rowCount);
    return res.rowCount === 1;
  }
  
  async userExists(name) {
    let query = 'SELECT name FROM users WHERE name=$1';
    const res = await this.client.query(query, [name]);
    console.log('count', res.rowCount);
    return res.rowCount === 1;
  }

  async getAllUsers(){
    let query = 'SELECT name, password FROM users';
    const res = await this.client.query(query);
    return res.rows;
  }

  async getAllAreas(){
    let query = 'SELECT name FROM places';
    const res = await this.client.query(query);
    return res.rows;
  }
}

const database = new Database(process.env.DATABASE_URL);

export { database };